# 基础

**select的执行顺序为：from where group having order by limit ** 

- 游标（Cursor）：指向结果集的指针

    - ```sql
        -- 使用场景：逐行处理数据、复杂业务逻辑实现(可能需要根据当前行的数据来决定下一行的处理方式)。
        -- 使用步骤：声明并关联指定结果集、打开、提取(Fetch)、关闭、释放
        -- 优点就是灵活、控制精细；
        -- 缺点 性能开销大
        ```

- 数据库中的层次模型是指树状结构组织数据，即一对多。
- sql注入防范措施：参数化查询、输入验证和过滤
- MySQL有一个内置的BENCHMARK(count,expr)函数，可以测试某些特定操作的执行速度
- limit 后面接一个数字为直接获取几行比如 limit 2 获取前两行。 后面接两个数字比如limit 0 5为从第一行开始获取5行，第一个数字是从0开始记的。
- 窗口函数

    - ```sql
        保留原始行数 ：与聚合函数不同，窗口函数不会将多行数据合并为一行，而是为每一行生成一个计算结果。
        支持分组和排序 ：窗口函数可以在指定的分组内进行排序，并基于这些排序进行计算。
        灵活的窗口定义 ：可以通过 OVER() 子句定义窗口的范围，包括分区、排序和框架（ROWS/RANGE）
        ```

    - 


#  SQL语言的类型

| 类型 | 描述         | 功能                             |
| ---- | ------------ | -------------------------------- |
| DML  | Manipulation | 数据的增删改查(CURD)             |
| DDL  | Definition   | 表的增删改查、视图、索引等的操作 |
| DCL  | Control      | 事务的提交和回滚                 |

# 笛卡尔积

一种集合运算。
$$
A、B\ 两集合,\quad \text{Cartesian product}(A,B)=\{(a,b)\ |\ a\in A, b\in B\}
$$
多表查询的过程中其实就会构造多个表的一个笛卡尔积，按照给定条件(连接条件)，从笛卡尔全集中选出正确的结果。

根据连接条件的不同可以划分为：等值链接、不等值链接、外链接、自连接。

- 外连接：包含条件不成立的记录
    - 左外连接、右外连接
- 自连接：通过表的别名，将同一张表视为多张表，然后进行连接。

# 事务

## ACID

- 原子性（Atomicity）

- 一致性（Consistency）

    - 事务必须使数据库从一个一致性状态变换到另一个一致性状态。也就是说，在事务开始之前和结束之后，数据库都要满足一定的完整性约束条件。以银行账户为例，账户余额总和在事务前后应该保持不变（不考虑利息等因素）。如果转账事务成功，那么账户 A 减少的金额应该等于账户 B 增加的金额，这样数据库的状态始终是符合财务规则的一致性状态。

- 隔离性（Isolation）

    - 多个事务并发执行时，一个事务的执行不能被其他事务干扰。每个事务都感觉不到其他事务在并发执行。例如，有两个转账事务同时进行，事务 1 是从账户 A 转账到账户 B，事务 2 是从账户 C 转账到账户 D。这两个事务应该是相互独立的，它们对数据库的操作不会相互影响，就好像它们是一个一个顺序执行的一样。不过在实际情况中，根据不同的 **隔离级别** ，这种独立性会有不同程度的保证，后面会详细介绍。

- 持久性（Durability）

    - 持久性是指一旦事务提交成功，它对数据库中数据的改变就是永久性的。即使系统出现故障，如断电、软件崩溃等，已经提交的事务的数据修改也不会丢失。例如，当转账事务成功提交后，账户 A 和账户 B 的余额修改会被持久地记录在数据库存储介质（如硬盘）中，不会因为后续的故障而恢复到之前的状态。

## 隔离级别

- 未提交读（Read Uncommitted）
    - 这是最低的隔离级别。在这个级别下，一个事务可以读取另一个未提交事务的数据。这种情况可能会导致 **脏读（Dirty Read）问题，即读取到了其他事务还未提交的数据，而这些数据可能因为事务回滚而最终不存在。** 
- 提交读（Read Committed）（Oracle默认）
    - 在这个级别下，一个事务只能读取另一个已提交事务的数据，避免了脏读问题。但是可能会出现 **不可重复读（Non - Repeatable Read）的情况。例如，事务 A 读取了一个数据值，然后事务 B ==修改== 并提交了这个数据，当事务 A 再次读取这个数据时，发现数据值已经改变了，这就导致同一事务内对同一数据的读取结果不可重复。** 
- 可重复读（Repeatable Read）（MySQL默认）
    - 这个级别可以保证在一个事务中多次读取同一数据时，其结果是相同的，避免了不可重复读的问题。不过可能会出现 **幻读（Phantom Read）现象。幻读是指当事务 A 在按照一定条件读取数据时，没有发现符合条件的数据，但是当事务 B ==插入了新的数据== 并且满足事务 A 的读取条件后，事务 A 再次读取时，就会发现有新的数据出现，就好像出现了 “幻影” 一样。** 
- 串行化（Serializable）
    - 这是最高的隔离级别，它要求事务串行执行，就像一个一个顺序操作一样，完全避免了脏读、不可重复读和幻读的问题。但是这种方式会严重影响系统的并发性能，因为它限制了事务的并发程度。

> 当启用 **事务自动提交** 时，每个 SQL 语句都被视为一个独立的事务，执行后会立即提交，将其对数据库的修改永久保存。反之，当关闭自动提交时，多个 SQL 语句可以组合成一个事务，只有在显式执行 `COMMIT` 语句后才会将这些操作提交到数据库，或者在执行 `ROLLBACK` 语句时将其回滚。

# 范式

### 第一范式（1NF）
   - **定义**：确保每列都是原子的，不可再分。

### 第二范式（2NF）
   - **定义**：在1NF的基础上，消除 部分函数依赖。
   - **要求**：所有非主键字段必须完全依赖于主键，而不是依赖于主键的一部分。
   - **示例**：
     - 不符合2NF的表：`订单表(订单ID, 产品ID, 产品名称, 订单日期)`，其中`产品名称`依赖于`产品ID`，而不是`订单ID`。
     - 符合2NF的表：将表拆分为`订单表(订单ID, 产品ID, 订单日期)`和`产品表(产品ID, 产品名称)`。

### 第三范式（3NF）
   - **定义**：在2NF的基础上，消除 传递函数依赖。
   - **要求**：所有非主键字段必须直接依赖于主键，而不能依赖于其他非主键字段。
   - **示例**：
     - 不符合3NF的表：`订单表(订单ID, 客户ID, 客户姓名, 订单日期)`，其中`客户姓名`依赖于`客户ID`，而不是直接依赖于`订单ID`。
     - 符合3NF的表：将表拆分为`订单表(订单ID, 客户ID, 订单日期)`和`客户表(客户ID, 客户姓名)`。

### 巴斯-科德范式（BCNF）
   - **定义**：在3NF的基础上，进一步消除主属性对 候选键的部分函数依赖。
   - **要求**：对于每一个函数依赖 `X → Y`，`X` 必须是超键（即 `X` 可以唯一确定一行）。
   - **示例**：
     - 不符合BCNF的表：`学生选课表(学生ID, 课程ID, 教师ID)`，假设每个课程只有一个教师，但一个教师可以教多门课程。这里`课程ID → 教师ID`，但`课程ID`不是超键。
     - 符合BCNF的表：将表拆分为`学生选课表(学生ID, 课程ID)`和`课程教师表(课程ID, 教师ID)`。

