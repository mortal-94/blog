- 当数组名作为 `sizeof` 操作符的操作数的时候，此时 `sizeof` 返回的是整个数组的长度，而不是指针数组指针的长度。
- 当数组名作为&操作符的操作数的时候，此时返回的是一个指向数组的指针（如 `int (*)[10]`），而不是指向某个数组元素的指针常量。
- 指针可以自增自减，但数组作为常量不可。（int a[10]; a++; 非法）
- static 修饰的变量具有内部链接性，无法在其他文件使用。

- 用异或交换两个相同类型的整型：

```c++
a = a ^ b;		// 记录两者异或结果
b = a ^ b;		// a ^ b ^ b 等于 a，即 b 赋值 a。
a = a ^ b;		// a ^ b ^ a 等于 b，即 a 赋值 b
```

- 函数指针

```c++
typedef int(p)(int, int);
void my_func(int a,int b){
	printf("%d %d\n",a,b);
}
void test(){
	p p1;
	//p1(10,20); //错误，不能直接调用，只描述了函数类型，但是并没有定义函数体，没有函数体无法调用
	p* p2 = my_func;	// 要用*
	p2(10,20); //正确，指向有函数体的函数入口地址
}
```

- endl 是输出换行并刷新缓冲区。
- 使用 `using namespace A;` 会将它的所有名称引入全局作用域（本文件，类似static）。而使用 `using A::parmA` 则是引入局部作用域。
-   左值为Lvalue，L代表Location，表示内存可以寻址，可以赋值。右值为Rvalue，R代表Read,就是可以知道它的值。
- c中const默认为外部连接，c++中const默认为内部连接。
- 引用的本质在c++内部实现是一个常指针，引用作为其它变量的别名而存在，函数调用时传递的实参不必加“&”符，使用也不必加“*”符号。
- C++内联函数(inline)会在适当的地方像预定义宏一样展开，必须函数体和声明结合在一起。它解决C中预定义宏存在的一些问题。任何在类内部定义的函数自动成为内联函数。内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。
- 如果函数声明和函数定义分开，函数声明设置了默认参数，函数定义不能再设置默认参数
- extern "C"的主要作用就是为了实现c++代码能够调用其他c语言代码。()
- **先调用对象成员的构造函数**，再调用本身的构造函数，析构函数则相反
- 当我们使用一个delete的时候，我们必须让delete知道指针指向的内存空间中是否存在一个“数组大小记录”的办法就是我们告诉它。当我们使用delete[]，那么delete就知道是一个对象数组，从而清楚应该调用几次析构函数。

# 虚函数与多态

- 虚函数允许子类（派生类）重新定义父类（基类）成员函数，而子类（派生类）重新定义父类（基类）虚函数的做法称为覆盖(override)，或者称为重写。
- 当使用`delete`操作符通过基类指针删除一个对象时，如果基类的析构函数是虚析构函数，C++ 会根据对象的实际类型（即派生类类型）来调用析构函数（理解为析构函数也被重新定义）。首先调用派生类的析构函数，以释放派生类中动态分配的资源，然后再调用基类的析构函数。
- 当你使用基类指针接收派生类指针时，指针的静态类型是基类类型，而指针的动态类型是派生类类型。静态类型是指在编译时确定的类型，即指针声明时的类型；动态类型是指指针在运行时实际指向的对象的类型。
- 使用基类指针接收派生类指针时，只能调用基类中声明的函数，或者派生类中重写基类的函数（多态性）。
- 若要调用派生类特有的函数，需要使用 `dynamic_cast` 进行向下转型，并检查转换是否成功，以避免运行时错误。



---

- 类模板的声明和实现放到一个文件中，我们把这个文件命名为.hpp(这个是个约定的规则，并不是标准，必须这么写).
- STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator),容器和算法之间通过迭代器进行无缝连接。



